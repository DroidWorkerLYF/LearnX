# 内存泄露
## 内存分配
### 静态区，堆，栈
```
	public class Simple {
		int s1 = 0;
		Sample mSample1 = new Sample();
		
		public void method() {
			int s2 = 1;
			Sample mSample2 = new Sample();
		}
		
	}
	
	Sample mSample3 = new Sample();
```

局部变量`s2`和`mSample2`位于栈，但是`mSample2`指向的对象位于堆。mSample3指向的对象实体位于堆，包括`s1`和`mSample1`，但是自身位于栈.

Java中数据存放区域  

1. 寄存器
2. 栈
3. 堆
4. 静态存储区
5. 常量池
6. 非RAM存储

静态区和常量池常看做一个区域。我们平时主要关心的就是静态存取区，栈，堆。

1. 静态存储区：存放static声明的静态成员(static)，字符串常量和基本类型常量(public static final)。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
2. 栈区：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
3. 堆区：又称动态内存分配，通常就是指在程序运行时直接`new`出来的内存。这部分内存在不使用时将会由垃圾回收器来负责回收。

### 堆，栈对比
在方法体内定义的局部变量(基本数据类型和对象的引用)都是在栈内存中分配。挡在一个方法内定义一个变量时，Java会在栈中为该变量分配内存空间，超过作用域后，会被回收。

堆内存用来存放所有由`new`关键字创建的对象(包括对象中所有的成员变量)和数组。在堆中分配的内存由垃圾回收器自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个引用变量指向他们在堆内存中的首地址。

|     | 栈 | 堆 |
|:--: |:--:| :--:|
| 内存分配速度 | 较快 | 较慢 |
| 灵活性      | 不灵活，大小和生存期必须是确定的 | 较灵活 |
| 生命周期    | 超过作用域则结束 | 当引用计数器为0时，等待垃圾回收或者程序结束 |

### 常用数据类型和对象的存储
#### 8种基本数据类型
`byte，short，int，long，double，float，boolean，char`

如int a = 3，这里的a是一个指向int类型的引用，指向3这个字面值。字面值的数据，由于大小可知，生存期可知，为了速度，就存在栈中。并且由于栈中数据可以共享
```
 	int a = 3;
 	int b = 3;
```

编译器先处理`int a = 3`；首先他会在栈中创建一个变量为`a`的引用，然后查找有没有字面值3的地址，没找到，就开辟一个存放3这个字面值的地址，然后让`a`指向3的地址，接着处理`int b = 3`，在创建完`b`这个引用变量后，由于栈中已经存在了3这个字面值，便直接将b指向3的地址。这样，就出现了`a`与`b`同时指向3。这是在让`a = 4`，那么b不会受影响。在编译器内部，会重新搜索栈中是否有4这个字面值，如果没有，就开辟地址存放4，有的话，则将`a`指向这个地址。

除了基本数据类型，我们知道还有对应的包装类，如`Integer`，`Double`，这些就和普通对象一样了。接下来看一下对象。

#### 对象
接上边提到的，`Integer i = new Integer(10)`，此时数据是存储在堆中的，而引用i则是存储在栈中。
在Java中，创建一个对象包括声明和实例化两步。

##### String
String是一个特殊的包装类。可以用以下两种方式创建
```
	String str = new String("abc");
	String str = "abc";
```

第一种方式和普通`new`一个对象一样。  
第二种方式Java内部将语句转化为：
1. 定义一个名为str的String类型对象引用变量
2. 在栈中查找有没有存放"abc"这个字面值的地址，如果没有，则创建一个存放"abc"的地址，接着创建一个新的String类型对象o，并将o的字符串值指向这个地址，而且在栈这个地址旁边记录下这个引用的对象；如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。
3. 将str指向对象o的地址。

一般String类中字符串都是直接存值的，但是上述第二种创建方式，却是存的一个指向栈中的引用。  

所以

```
	String str1 = "abc"；
	String str2 = "abc"；
	System.out.println(s1 == s2)；//true
	
	String str1 = new String("abc");
	String str2 = "abc";
	System.out.println(s1 == s2)；//false
```

### Finalize
`finalize()`方法是java提供的一种机制，使得你能够在对象被垃圾回收前运行一些代码。由于不能保证对象被垃圾回收，所以此方法中的代码无法保证运行。

### Final
final只对引用的值有效，即对象的内存地址。

### 引用
1. 强引用`StrongReference`：new出来的对象，尽可能长时间的存活，引用计数为0时，GC后被回收。
2. 软引用`SoftReference`：尽可能长的保留，知道内存紧张时才会回收。可配合引用队列(ReferenceQueue)使用。
3. 弱引用`WeakReference`：没有强引用，进行GC时会被回收。可配合引用队列(ReferenceQueue)使用。
4. 虚引用`PhantomReference`：虚引用可以忽略不计，唯一作用是做一些跟踪记录，辅助`finalize`函数。必须配合引用队列(ReferenceQueue)使用。

## GC
1. 垃圾回收并不会按照程序员的要求，随时进行GC
2. 垃圾回收并不会及时的清理内存
3. 程序员不能对垃圾回收进行控制

### 算法
#### 引用计数法
对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减 1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。但是引用计数器有一个严重的问题，即无法处理循环引用的情况。因此，在Java的垃圾回收器中没有使用这种算法。

一个简单的循环引用问题描述如下：有对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。

#### 标记-清除算法
标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段首先通过根节点，标记所有从根节点开始的较大对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。该算法最大的问题是存在大量的空间碎片，因为回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续的空间。

#### 复制算法
将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。
如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。
Java 的新生代串行垃圾回收器中使用了复制算法的思想。新生代分为 eden 空间、from 空间、to 空间 3 个部分。其中 from 空间和 to 空间可以视为用于复制的两块大小相同、地位相等，且可进行角色互换的空间块。from 和 to 空间也称为 survivor 空间，即幸存者空间，用于存放未被回收的对象。
在垃圾回收时，eden 空间中的存活对象会被复制到未使用的 survivor 空间中 (假设是 to)，正在使用的 survivor 空间 (假设是 from) 中的年轻对象也会被复制到 to 空间中 (大对象，或者老年对象会直接进入老年带，如果 to 空间已满，则对象也会直接进入老年代)。此时，eden 空间和 from 空间中的剩余对象就是垃圾对象，可以直接清空，to 空间则存放此次回收后的存活对象。这种改进的复制算法既保证了空间的连续性，又避免了大量的内存空间浪费。

#### 标记-压缩算法
复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。
标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。也首先需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

#### 增量算法
在垃圾回收过程中，应用软件将处于一种 CPU 消耗很高的状态。在这种 CPU 消耗很高的状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。
增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

### 分代
![](https://github.com/DroidWorkerLYF/LearnX/blob/master/Memory/JVM_Generation.jpg?raw=true)

1. Young Generation：新生代，From/to 合起来是Survivor区，这两个区域大小相同，新建对象由新生代区分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中。
2. Old Generation：旧生代，用于存放新生代中经过多次垃圾回收仍然存活的对象。
3. Permanent Generation：持久代，JVM中不一定有这一代。


根据垃圾回收对象的特性，不同阶段最优的方式是使用合适的算法用于本阶段的垃圾回收，分代算法即是基于这种思想，它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。以 Hot Spot 虚拟机为例，它将所有的新建对象都放入称为新生代的内存区域，新生代的特点是对象会很快回收，因此，在新生代就选择效率较高的复制算法。当一个对象经过几次回收后依然存活，对象就会被放入称为旧生代的内存空间。在旧生代中，几乎所有的对象都是经过几次垃圾回收后依然得以幸存的。因此，可以认为这些对象在一段时期内，甚至在应用程序的整个生命周期中，将是常驻内存的。如果依然使用复制算法回收老生代，将需要复制大量对象。再加上老生代的回收性价比也要低于新生代，因此这种做法也是不可取的。根据分代的思想，可以对旧生代的回收使用与新生代不同的标记-压缩算法，以提高垃圾回收效率。

## 内存优化建议
1. 尽早释放无用的引用。好的办法是使用临时变量，超过作用域后，自动将引用变量置为null，因为垃圾回收会将值为null的对象视为垃圾，这样可以提高回收效率。
2. 定义字符串尽量使用`String str = "hello"`。
3. 处理大量字符串，使用`StringBuffer`，因为`String`是不可变的(immutable)。
4. 避免在构造函数中创建初始化大量对象。
5. 显示的生命数组控件。
6. 使用对象池
7. 不要再经常调用的方法中创建对象，尤其是循环中
8. 尽量避免使用`finalize`方法，会加大GC工作量
9. 不要过度使用hash表来缓存数据。


## 泄露的定位
### 静态代码分析工具 - Lint
Lint是Android Studio自带的工具，可以在不写test case，不运行app的情况下，静态的检查代码结构质量问题.在菜单Analyze -> Inspect code中，可以设定Lint扫描范围，对于可能引起内存泄露的问题，会在结果中呈现。  
FindBugs  
[Improve Your Code with Lint](https://developer.android.com/studio/write/lint.html#overview)

### 严苛模式 - StrictMode
[StrictMode](https://developer.android.com/reference/android/os/StrictMode.html)

### Analyzer Task & MAT
[Analyzer Task & MAT](https://github.com/DroidWorkerLYF/LearnX/blob/master/Memory/Analyzer%20Task%20and%20MAT.md)

### LeakCanary
分析了[LeakCanary](https://github.com/square/leakcanary)基本的[工作流程]
(https://github.com/DroidWorkerLYF/LearnX/blob/master/Android/LeakCanary/LeakCanary学习分析.md)

## 常见内存泄露
1. 集合
2. 单例
3. 匿名内部类/非静态内部类
4. Handler
5. 未解绑
6. 无限循环动画

### 参考的文章
[极客学院 Java 内存管理](http://wiki.jikexueyuan.com/project/java-special-topic/platorm-memory.html)  
[Java内存布局及Java各种存储区域(详解)](http://blog.csdn.net/waitforfree/article/details/38781927)  
[Android应用内存泄漏的定位、分析与解决策略]([http://www.jianshu.com/p/96c55ea3446e?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io](http://www.jianshu.com/p/96c55ea3446e?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io))
[JVM 垃圾回收器工作原理及使用实例介绍](http://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/index.html)  
[Java之美[从菜鸟到高手演变]之JVM内存管理及垃圾回收](http://blog.csdn.net/zhangerqing/article/details/8214365)