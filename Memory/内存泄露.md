# 内存泄露
## 内存分配
### 静态，堆，栈
```
	public class Simple {
		int s1 = 0;
		Sample mSample1 = new Sample();
		
		public void method() {
			int s2 = 1;
			Sample mSample2 = new Sample();
		}
		
	}
	
	Sample mSample3 = new Sample();
```

局部变量`s2`和`mSample2`位于栈，但是`mSample2`指向的对象位于堆。mSample3指向的对象实体位于堆，包括`s1`和`mSample1`，但是自身位于栈.

Java程序运行时的内存分配策略有三种，分别是静态分配，栈式分配，和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区(也称方法区)，栈区和堆区。

1. 静态存储区(方法区)：主要存放静态数据、全局static数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。
2. 栈区：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
3. 堆区：又称动态内存分配，通常就是指在程序运行时直接`new`出来的内存。这部分内存在不使用时将会由垃圾回收器来负责回收。

### 堆，栈对比
在方法体内定义的局部变量(基本数据类型和对象的引用)都是在栈内存中分配。挡在一个方法内定义一个变量时，Java会在栈中为该变量分配内存空间，超过作用域后，会被回收。

堆内存用来存放所有由`new`关键字创建的对象(包括对象中所有的成员变量)和数组。在堆中分配的内存由垃圾回收器自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个引用变量指向他们在堆内存中的首地址。

|     | 堆 | 栈 |
|:--: |:--:| :--:|
| 优点 | 动态分配 | 速度快，仅次于寄存器，可以共享         |
| 缺点 | 速度较慢 | 数据大小，生存期必须是确定的，缺乏灵活性 |

### 常用数据类型和对象的存储
#### 8中基本数据类型
`byte，short，int，long，double，float，boolean，char`

如int a = 3，这里的a是一个指向int类型的引用，指向3这个字面值。字面值的数据，由于大小可知，生存期可知，为了速度，就存在栈中。并且由于栈中数据可以共享
```
 	int a = 3;
 	int b = 3;
```

编译器先处理`int a = 3`；首先他会在栈中创建一个变量为`a`的引用，然后查找有没有字面值3的地址，没找到，就开辟一个存放3这个字面值的地址，然后让`a`指向3的地址，接着处理`int b = 3`，在创建完`b`这个引用变量后，由于栈中已经存在了3这个字面值，便直接将b指向3的地址。这样，就出现了`a`与`b`同时指向3。这是在让`a = 4`，那么b不会受影响。在编译器内部，会重新搜索栈中是否有4这个字面值，如果没有，就开辟地址存放4，有的话，则将`a`指向这个地址。

除了基本数据类型，我们知道还有对应的包装类，如`Integer`，`Double`，这些就和普通对象一样了。接下来看一下对象。

#### 对象
接上边提到的，`Integer i = new Integer(10)`，此时数据是存储在堆中的，而引用i则是存储在栈中。
在Java中，创建一个对象包括声明和实例化两步。

##### String
String是一个特殊的包装类。可以用以下两种方式创建
```
	String str = new String("abc");
	String str = "abc";
```

第一种方式和普通`new`一个对象一样。  
第二种方式Java内部将语句转化为：
1. 定义一个名为str的String类型对象引用变量
2. 在栈中查找有没有存放"abc"这个字面值的地址，如果没有，则创建一个存放"abc"的地址，接着创建一个新的String类型对象o，并将o的字符串值指向这个地址，而且在栈这个地址旁边记录下这个引用的对象；如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。
3. 将str指向对象o的地址。

一般String类中字符串都是直接存值的，但是上述第二种创建方式，却是存的一个指向栈中的引用。  

所以
```
	String str1 = "abc"；
	String str2 = "abc"；
	System.out.println(s1 == s2)；//true
	
	String str1 = new String("abc");
	String str2 = "abc";
	System.out.println(s1 == s2)；//false
```

### Finalize
`finalize()`方法是java提供的一种机制，使得你能够在对象被垃圾回收前运行一些代码。由于不能保证对象被垃圾回收，所以此方法中的代码无法保证运行。

### Final
final只对引用的值有效，即对象的内存地址。

### 引用
1. 强引用`StrongReference`：刚被new出来的对象，不会被回收。
2. 软引用`SoftReference`：如果JVM不紧张，这类引用对象不会被回收。
3. 弱引用`WeakReference`：进行GC时，一定会被回收。
4. 虚引用`PhantomReference`：虚引用可以忽略不计，唯一作用是做一些跟踪记录，辅助`finalize`函数。

## GC

## 内存优化建议
1. 尽早释放无用的引用。好的办法是使用临时变量，超过作用域后，自动将引用变量置为null，因为垃圾回收会将值为null的对象视为垃圾，这样可以提高回收效率。
2. 定义字符串尽量使用`String str = "hello"`。
3. 处理大量字符串，使用`StringBuffer`，因为`String`是不可变的(immutable)。
4. 避免在构造函数中创建初始化大量对象。
5. 显示的生命数组控件。
6. 使用对象池
7. 不要再经常调用的方法中创建对象，尤其是循环中
8. 尽量避免使用`finalize`方法，会加大GC工作量
9. 不要过度使用hash表来缓存数据。


## 泄露的定位
### 静态代码分析工具 - Lint
Lint是Android Studio自带的工具，可以在不写test case，不运行app的情况下，静态的检查代码结构质量问题.在菜单Analyze -> Inspect code中，可以设定Lint扫描范围，对于可能引起内存泄露的问题，会在结果中呈现。  
FindBugs  
[Improve Your Code with Lint](https://developer.android.com/studio/write/lint.html#overview)

### 严苛模式 - StrictMode
[StrictMode](https://developer.android.com/reference/android/os/StrictMode.html)

### MAT

### LeakCanary
分析了[LeakCanary](https://github.com/square/leakcanary)基本的[工作流程]
(https://github.com/DroidWorkerLYF/LearnX/blob/master/Android/LeakCanary/LeakCanary学习分析.md)

## 常见内存泄露
### 集合

### 单例

### 匿名内部类/非静态内部类

### Handler

### 未解绑

### 无限循环动画